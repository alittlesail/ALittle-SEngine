
register namespace lua;

public class __CPPAPIServerSchedule
{
    // 数据库
    public fun StartMysqlQuery(int thread_count, string ip, string username, string password, int port, string db_name) {}
    public fun AddMysqlStatement(int thread_id, int query_id, lua.__CPPAPIMysqlStatementQuery query) : bool {}
    public fun AddMysqlNormal(int thread_id, int query_id, string sql) : bool {}
    public fun AddMysqlEmpty(int thread_d, int query_id) : bool {}

    // http客户端
    public fun HttpGet(int id, string url) {}
    public fun HttpPost(int id, string url, string type, string content) {}

    // http服务器
    public fun CreateHttpServer(string yun_ip, string ip, int port, bool is_ssl) : bool {}
    public fun GetHttpServerYunIp() : string {}
    public fun GetHttpServerIp() : string {}
    public fun GetHttpServerPort() : int {}

    public fun HttpClose(int http_id) {}
    public fun HttpSendString(int http_id, string content) {}
    public fun HttpSendFile(int http_id, string file_path, int start_size) {}
    public fun HttpStartReceiveFile(int http_id, string file_path, int start_size) : bool {}

    // 客户端服务，如果rudp设置为true，表示打开udp可靠性服务
    public fun CreateClientServer(string yun_ip, string ip, int port, bool rudp) : bool {}
    public fun GetClientServerYunIp() : string {}
    public fun GetClientServerIp() : string {}
    public fun GetClientServerPort() : int {}

    public fun ClientClose(int client_id) {}
    public fun ClientSend(int client_id, ALittle.IMessageWriteFactory factory) {}

    // 释放rtp
    public fun ReleaseRtp(int first_port) {}
    // 释放所有rtp
    public fun ReleaseAllRtp() {}

    // 设置线路方的rtp
    public fun SetRemoteRtp(int first_port, string remote_rtp_ip, int remote_rtp_port) {}

    // 设置内部转发rtp
    public fun SetInnerRtp(int first_port, string inner_rtp_ip, int inner_rtp_port) {}

    // 转接到client_id
    public fun TransferToClient(int first_port, int client_id) {}

    // 清理空闲rtp，可以定时调用
    // idle_delta_time 表示超过多少秒的空闲清理掉
    public fun ClearIdleRtp(int idle_delta_time) {}

    // 开始使用rtp
	// client_rtp_ip_string 表示要使用的ip列表，多个用;隔开，用于和客户端互发媒体包。
	//						因为客户端的网络可能是不同运营商，运营商之前会互相拦截数据包
	//						所以这里可以开多个不同的运营商ip，来兼容客户端不同的网络
	// self_rtp_ip 表示要使用的ip，用于和线路方互发RTP包
	// inner_rtp_ip 表示要使用的ip，用于内部rtp服务器转发媒体包，用于转接的场景
    // remote_rtp_ip 表示线路方的ip，已经确定了就不填空串
    // call_id SIP协议中的CALL-ID
    // client_id 和客户端通话的标识
    // ssrc 和线路通话的标识
    public fun UseRtp(int first_port
                     , string client_rtp_ip_string, int client_rtp_port
                     , string self_rtp_ip, int self_rtp_port
                     , string inner_rtp_ip, int inner_rtp_port
                     , string remote_rtp_ip, int remote_rtp_port
                     , string call_id, int client_id, int ssrc) {}

	// 启动服务器
	public fun CreateUdpServer(string ip, int port) : bool {}
    public fun CloseUdpServer(string ip, int port) {}
    // 设置参数
	// self_ip，self_port 自己这一方面的IP和端口
    // remote_ip, remote_port 对端的IP和端口
    // message 要发送的消息内容
    public fun SendUdpMessage(string self_ip, int self_port, string remote_ip, int remote_port, string message) {}

    // 服务端服务
    public fun StartRouteSystem(int route_type, int route_num) {}
    public fun GetRouteType() : int {}
    public fun GetRouteNum() : int {}
    public fun GetRouteId() : int {}

    public fun CreateConnectServer(string yun_ip, string ip, int port) {}
    public fun GetConnectServerYunIp() : string {}
    public fun GetConnectServerIp() : string {}
    public fun GetConnectServerPort() : int {}
    
    public fun CreateConnectClient(string ip, int port) {}
    public fun ConnectSession(int route_type, int route_num) {}
    public fun CalcConnectKey(int src_route_type, int src_route_num, int dst_route_type, int dst_route_num) : int {}
    
    public fun SessionClose(int connect_key) { }
    public fun SessionSend(int connect_key, ALittle.IMessageWriteFactory factory) {}
}

public var __CPPAPI_ServerSchedule:__CPPAPIServerSchedule;
